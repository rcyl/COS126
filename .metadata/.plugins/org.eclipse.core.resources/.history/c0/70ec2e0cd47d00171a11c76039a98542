1.keep reading from stdin unitil FFFF is encountered

/* register map */

r0 base
r1 m0
r2 m1
r3 m2
r4 m3
r5
r6
r7
r8
r9 = t0
rA = t1
rB = t2
rC = t3
rD = const0
rE = const1
rF = const2

/* mem map */

mem[0x40] = m0
mem[FE] = memFFFF /* put constant into memory */
mem[halt] = memHalt
mem[calc] = memCalc

/* "load address" is anything, but "load" deferences memory */

/*************** ASSEMBLY *****************/
loadaddr base, m0
loadaddr i , 0
load constant1, memFFFF

int i = 0;
while(true) {
	cur = readstdin
	if (cur = 0xFFFF)
		return;

	

}


main:	
while(true) {
	read from stdin into reg
	load t0, mem[FF] /* t0 has current value */

	if (reg == 0xFFFF)
		halt
	xor 	t0, temp, const1 
	bzero	t0, memHalt /* to be defined */
	
	else
		store t0 as m[i] /* t0 is cur m value */
		
		add t1, base, idx /* t1 has base + idx */
		sind t0, 0, t1 /* store to into base + idx */
		load t0, mem[FF] /* print out
		
		/*if (i == 4) :
			memCalc */
		loadaddr t1, 4 /* load idx with 4 */
		xor t1, t1, idx /* xor idx with 4 */
		bzero t1, parCalc
			
		add idx, idx, 1 /* increment i by 1 */
		j main
}
	
parCalc:

	pa = m[0] ^ m[1] ^ m[2] ^ m[3];
	pa = 0;
	for(int i = 0; i < 4; i++) 
		pa ^= m[i] 
	
	loadaddr pa, 0 // cur = 0
	loadaddr idx, 0 // idx = 1
	loadaddr size, 4 // size
loop:
	xor temp, idx, size // idx == size ?
	bzero temp, loop2 // jump to loop2
	add temp, base + idx 
	load temp, temp  // temp = mem[base + idx]
	xor pa, pa, temp // pa ^= m[base + idx]
	add idx, idx, 1 // i++
	j loop
	
	p[0] = pa ^ m[2]
	p[1] = pa ^ m[1]
	p[2] = pa ^ m[0]
	for(int i = 0; i < 3; i++) {
		temp = pa ^ m[2 - i];
		print temp 
	}
	
	loadaddr idx, 0
	loadaddr size, 3
	loadaddr size2, 2
loop2:
	xor temp, idx, size // idx == size?
	bzero temp, main // jump back to main
	sub temp, size2, idx // temp = 2 - idx
	load temp, temp // temp = mem[2 - idx]
	xor temp, temp, pa // temp = pa ^  mem[2 - idx]
	load temp, FF //print to stdout
	add idx, idx, 1 //i++
	j loop2
	

	